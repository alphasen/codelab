#!/usr/bin/env node

'use strict';

var colors     = require('colors/safe'),
    os         = require('os'),
    codelab = require('../lib'),
    portfinder = require('portfinder'),
    opener     = require('opener'),
    argv = require('minimist')(process.argv.slice(2));

var ifaces = os.networkInterfaces();

if (argv.h || argv.help) {
    console.log([
      'usage: codelab [path] [options]',
      '',
      'options:',
      '  -p --port    Port to use [8080]',
      '  -a           Address to use [0.0.0.0]',
      '  -d           Show directory listings [true]',
      '  -i           Display autoIndex [true]',
      '  -g --gzip    Serve gzip files when possible [false]',
      '  -b --brotli  Serve brotli files when possible [false]',
      '               If both brotli and gzip are enabled, brotli takes precedence',
      '  -e --ext     Default file extension if none supplied [none]',
      '  -s --silent  Suppress log messages from output',
      '  --cors[=headers]   Enable CORS via the "Access-Control-Allow-Origin" header',
      '                     Optionally provide CORS headers list separated by commas',
      '  -no-open    Don\'t open browser window after starting the server.',
      '  -c           Cache time (max-age) in seconds [3600], e.g. -c10 for 10 seconds.',
      '               To disable caching, use -c-1.',
      '  -U --utc     Use UTC time format in log messages.',
      '  --log-ip     Enable logging of the client\'s IP address',
      '',
      '  -P --proxy   Fallback proxy if the request cannot be resolved. e.g.: http://someurl.com',
      '',
      '  --username   Username for basic authentication [none]',
      '               Can also be specified with the env variable NODE_HTTP_SERVER_USERNAME',
      '  --password   Password for basic authentication [none]',
      '               Can also be specified with the env variable NODE_HTTP_SERVER_PASSWORD',
      '',
      '  -r --robots  Respond to /robots.txt [User-agent: *\\nDisallow: /]',
      '  --no-dotfiles  Do not show dotfiles',
      '  -h --help    Print this list and exit.'
    ].join('\n'));
    process.exit();
  }

  var port = argv.p || argv.port || parseInt(process.env.PORT, 10),
      host = argv.a || '0.0.0.0',
      proxy = argv.P || argv.proxy,
      utc = argv.U || argv.utc,
      logger;

  if (!argv.s && !argv.silent) {
    logger = {
      info: console.log,
      request: function (req, res, error) {
        var date = utc ? new Date().toUTCString() : new Date();
        var ip = argv['log-ip']
            ? req.headers['x-forwarded-for'] || '' +  req.connection.remoteAddress
            : '';
        if (error) {
          logger.info(
            '[%s] %s "%s %s" Error (%s): "%s"',
            date, ip, colors.red(req.method), colors.red(req.url),
            colors.red(error.status.toString()), colors.red(error.message)
          );
        }
        else {
          logger.info(
            '[%s] %s "%s %s" "%s"',
            date, ip, colors.cyan(req.method), colors.cyan(req.url),
            req.headers['user-agent']
          );
        }
      }
    };
  }
  else if (colors) {
    logger = {
      info: function () {},
      request: function () {}
    };
  }

  if (!port) {
    portfinder.basePort = 3333;
    portfinder.getPort(function (err, port) {
      if (err) { throw err; }
      listen(port);
    });
  }
  else {
    listen(port);
  }

  function listen(port) {
    var options = {
      root: argv._[0],
      cache: argv.c,
      showDir: argv.d,
      autoIndex: argv.i,
      gzip: argv.g || argv.gzip,
      brotli: argv.b || argv.brotli,
      robots: argv.r || argv.robots,
      ext: argv.e || argv.ext,
      logFn: logger.request,
      proxy: proxy,
      showDotfiles: argv.dotfiles,
      username: argv.username || process.env.NODE_HTTP_SERVER_USERNAME,
      password: argv.password || process.env.NODE_HTTP_SERVER_PASSWORD
    };

    if (argv.cors) {
      options.cors = true;
      if (typeof argv.cors === 'string') {
        options.corsHeaders = argv.cors;
      }
    }


    var server = codelab.createServer(options);
    server.listen(port, host, function () {
      var canonicalHost = host === '0.0.0.0' ? '127.0.0.1' : host,
          protocol      = 'http://';

      logger.info([colors.yellow('Starting up codelab, serving '),
        colors.cyan(server.root),
        colors.yellow('\nAvailable on:')
      ].join(''));

      if (argv.a && host !== '0.0.0.0') {
        logger.info(('  ' + protocol + canonicalHost + ':' + colors.green(port.toString())));
      }
      else {
        Object.keys(ifaces).forEach(function (dev) {
          ifaces[dev].forEach(function (details) {
            if (details.family === 'IPv4') {
              logger.info(('  ' + protocol + details.address + ':' + colors.green(port.toString())));
            }
          });
        });
      }

      if (typeof proxy === 'string') {
        logger.info('Unhandled requests will be served from: ' + proxy);
      }

      logger.info('Hit CTRL-C to stop the server');
      if (!argv.hasOwnProperty('no-open')) { // go to browser
        var openUrl = protocol + canonicalHost + ':' + port;
        if (typeof argv.o === 'string') {
          openUrl += argv.o[0] === '/' ? argv.o : '/' + argv.o;
        }
        logger.info('open: ' + openUrl);
        opener(openUrl);
      }
    });
  }

  if (process.platform === 'win32') {
    require('readline').createInterface({
      input: process.stdin,
      output: process.stdout
    }).on('SIGINT', function () {
      process.emit('SIGINT');
    });
  }

  process.on('SIGINT', function () {
    logger.info(colors.red('codelab stopped.'));
    process.exit();
  });

  process.on('SIGTERM', function () {
    logger.info(colors.red('codelab stopped.'));
    process.exit();
  });
